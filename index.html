<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 Senate Forecast</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f1a; color: #eee;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 320px;
            min-height: 100vh;
        }

        .main-content {
            padding: 20px;
            overflow-y: auto;
        }

        h1 { text-align: center; margin-bottom: 5px; font-size: 24px; }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 14px; }

        /* Control Bar */
        .control-bar {
            display: flex; justify-content: center; gap: 40px;
            margin-bottom: 20px; padding: 15px;
            background: #1a1a2e; border-radius: 10px;
        }
        .control-stat { text-align: center; }
        .control-stat .label { font-size: 12px; color: #666; text-transform: uppercase; }
        .control-stat .value { font-size: 32px; font-weight: bold; }
        .control-stat.dem .value { color: #3b82f6; }
        .control-stat.rep .value { color: #ef4444; }

        /* Hex Map */
        .hex-map {
            display: flex; justify-content: center;
            margin-bottom: 20px;
        }
        .hex-grid {
            display: grid;
            grid-template-columns: repeat(12, 44px);
            gap: 2px;
        }
        .hex-cell {
            width: 44px; height: 38px;
            display: flex; align-items: center; justify-content: center;
            font-size: 11px; font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            border: 2px solid transparent;
            position: relative;
        }
        .hex-cell:hover { transform: scale(1.1); z-index: 10; }
        .hex-cell.selected { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .hex-cell.locked { border-color: #fbbf24; }
        .hex-cell.empty { visibility: hidden; }
        .hex-cell .prob {
            position: absolute; bottom: 2px; right: 3px;
            font-size: 8px; opacity: 0.8;
        }

        /* Snake Chart */
        .snake-section { margin-top: 20px; }
        .snake-section h2 { font-size: 16px; margin-bottom: 10px; color: #888; }
        .snake-chart {
            display: flex; flex-wrap: wrap; gap: 4px;
            padding: 10px;
            background: #1a1a2e; border-radius: 8px;
        }
        .snake-item {
            width: 50px; height: 36px;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            border: 2px solid transparent;
            transition: transform 0.1s;
        }
        .snake-item:hover { transform: scale(1.1); z-index: 10; }
        .snake-item.selected { border-color: #fff; }
        .snake-item.locked { border-color: #fbbf24; }
        .snake-item .state { font-weight: bold; }
        .snake-item .pct { font-size: 9px; opacity: 0.8; }

        /* Sidebar */
        .sidebar {
            background: #1a1a2e;
            border-left: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }
        .sidebar h2 { font-size: 14px; color: #888; margin-bottom: 15px; text-transform: uppercase; }

        .selected-race {
            background: #252540;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .selected-race .state-name { font-size: 20px; font-weight: bold; margin-bottom: 5px; }
        .selected-race .race-type { color: #666; font-size: 12px; margin-bottom: 10px; }
        .selected-race .prob-display {
            display: flex; gap: 20px; margin: 15px 0;
        }
        .selected-race .prob-item { text-align: center; }
        .selected-race .prob-item .party { font-size: 12px; color: #888; }
        .selected-race .prob-item .pct { font-size: 24px; font-weight: bold; }
        .selected-race .prob-item.dem .pct { color: #3b82f6; }
        .selected-race .prob-item.rep .pct { color: #ef4444; }

        .selected-race .actions { margin-top: 15px; }
        .selected-race .actions button {
            padding: 8px 16px; margin-right: 8px;
            border: none; border-radius: 4px;
            cursor: pointer; font-size: 12px;
        }
        .selected-race .actions .lock-d { background: #3b82f6; color: #fff; }
        .selected-race .actions .lock-r { background: #ef4444; color: #fff; }
        .selected-race .actions .unlock { background: #374151; color: #fff; }

        .locked-summary {
            background: #252540;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .locked-summary .locked-item {
            display: flex; justify-content: space-between;
            padding: 5px 0; border-bottom: 1px solid #333;
            font-size: 13px;
        }
        .locked-summary .locked-item:last-child { border-bottom: none; }
        .locked-summary .locked-item .outcome { font-weight: bold; }
        .locked-summary .locked-item .outcome.D { color: #3b82f6; }
        .locked-summary .locked-item .outcome.R { color: #ef4444; }
        .locked-summary .locked-item .outcome.I_Osborn { color: #fbbf24; }
        .locked-summary .locked-item .outcome.I_Other { color: #d97706; }

        .correlations {
            background: #252540;
            border-radius: 8px;
            padding: 15px;
        }
        .correlations h3 { font-size: 12px; color: #888; margin-bottom: 10px; }
        .corr-item {
            display: flex; justify-content: space-between;
            padding: 4px 0; font-size: 12px;
        }
        .corr-item .val { font-weight: bold; }
        .corr-item .val.pos { color: #22c55e; }
        .corr-item .val.neg { color: #ef4444; }

        .reset-all {
            width: 100%; padding: 10px;
            background: #374151; color: #fff;
            border: none; border-radius: 6px;
            cursor: pointer; margin-top: 20px;
        }
        .reset-all:hover { background: #4b5563; }

        .sample-count {
            text-align: center; color: #555; font-size: 11px;
            margin-top: 15px;
        }

        /* Methodology section */
        .methodology {
            background: #252540;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .methodology summary {
            cursor: pointer;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        .methodology summary:hover { color: #aaa; }
        .methodology dl { margin: 0; }
        .methodology dt {
            font-weight: bold;
            color: #bbb;
            margin-top: 10px;
            font-size: 12px;
        }
        .methodology dd {
            color: #888;
            font-size: 11px;
            margin-left: 0;
            margin-top: 2px;
            line-height: 1.4;
        }
        .methodology p {
            color: #888;
            font-size: 11px;
            margin: 10px 0;
            line-height: 1.4;
        }

        /* Histogram */
        .histogram-section { margin-top: 20px; }
        .histogram-section h2 { font-size: 16px; margin-bottom: 10px; color: #888; }
        .histogram-container {
            padding: 15px;
            background: #1a1a2e; border-radius: 8px;
        }
        .histogram {
            display: flex;
            align-items: flex-end;
            height: 120px;
            gap: 2px;
        }
        .hist-bar {
            flex: 1;
            min-width: 8px;
            background: #4a4a6a;
            border-radius: 2px 2px 0 0;
            position: relative;
            cursor: pointer;
            transition: opacity 0.1s;
        }
        .hist-bar:hover { opacity: 0.8; }
        .hist-bar.dem { background: linear-gradient(#3b82f6, #1d4ed8); }
        .hist-bar.rep { background: linear-gradient(#ef4444, #b91c1c); }
        .hist-bar.locked {
            box-shadow: 0 0 8px #fbbf24, inset 0 0 0 2px #fbbf24;
        }
        .hist-bar.majority-line {
            position: absolute;
            border-left: 2px dashed #fbbf24;
            height: 100%;
            pointer-events: none;
        }
        .histogram-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            padding: 0 2px;
        }
        .histogram-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 11px;
            color: #888;
        }
        .histogram-legend span { display: flex; align-items: center; gap: 5px; }
        .legend-box { width: 12px; height: 12px; border-radius: 2px; }
        .legend-box.dem { background: #3b82f6; }
        .legend-box.rep { background: #ef4444; }

        /* Markets Panel */
        .markets-panel {
            background: #252540;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .market-item {
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        .market-item:last-child { border-bottom: none; }
        .market-item a {
            color: #60a5fa;
            text-decoration: none;
            font-size: 12px;
            display: block;
            margin-bottom: 4px;
        }
        .market-item a:hover { text-decoration: underline; }
        .market-meta {
            font-size: 10px;
            color: #666;
        }
        .market-meta .vol { color: #22c55e; }
        .market-meta .bettors { color: #a78bfa; }
        .market-item.relevant { background: #1e3a5f; margin: 0 -15px; padding: 8px 15px; }
        .price-compare {
            font-size: 11px;
            color: #9ca3af;
            margin: 4px 0;
            font-family: monospace;
        }
        .price-compare.warning { color: #fbbf24; }
        .price-compare .diff {
            color: #6b7280;
            font-size: 10px;
        }
        .price-compare.warning .diff { color: #f59e0b; }

        /* Top Maps Panel */
        .top-maps {
            background: #252540;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .top-maps h3 { font-size: 12px; color: #888; margin-bottom: 10px; }
        .map-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            margin: 2px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .map-item:hover { background: #1a1a2e; }
        .map-item.selected { background: #2d2d50; border: 1px solid #4a4a8a; }
        .map-item .rank {
            width: 20px;
            font-size: 10px;
            color: #666;
            flex-shrink: 0;
        }
        .map-item .bar-container {
            flex: 1;
            height: 16px;
            background: #1a1a2e;
            border-radius: 3px;
            margin: 0 8px;
            overflow: hidden;
        }
        .map-item .bar {
            height: 100%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding-left: 4px;
            font-size: 9px;
            color: rgba(255,255,255,0.9);
        }
        .map-item .bar.r-control { background: linear-gradient(90deg, #ef4444, #b91c1c); }
        .map-item .bar.d-control { background: linear-gradient(90deg, #3b82f6, #1d4ed8); }
        .map-item .seats {
            width: 45px;
            font-size: 10px;
            text-align: right;
            color: #888;
            flex-shrink: 0;
        }
        .map-detail {
            background: #1a1a2e;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
            font-size: 11px;
        }
        .map-detail .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }
        .map-detail .stat-row .label { color: #888; }
        .map-detail .stat-row .value { font-weight: bold; }
        .map-detail .upsets {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }
        .map-detail .upset-tag {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            border-radius: 3px;
            font-size: 10px;
            background: #374151;
        }
        .clear-map-btn {
            width: 100%;
            padding: 6px;
            margin-top: 10px;
            background: #374151;
            color: #888;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .clear-map-btn:hover { background: #4b5563; color: #fff; }

        /* Sample Statistics Panel */
        .sample-stats {
            background: #252540;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .sample-stats h3 { font-size: 12px; color: #888; margin-bottom: 10px; }
        .stat-row {
            display: flex; justify-content: space-between;
            padding: 3px 0; font-size: 12px;
        }
        .stat-row .label { color: #888; }
        .stat-row .value { font-weight: bold; }
        .stat-row .value.warning { color: #fbbf24; }
        .stat-row .value.error { color: #ef4444; }

        .ci-display {
            margin-top: 10px; padding-top: 10px;
            border-top: 1px solid #333;
        }
        .ci-display .label { font-size: 11px; color: #666; margin-bottom: 5px; }
        .ci-bar {
            height: 20px; background: #1a1a2e; border-radius: 4px;
            position: relative; overflow: hidden;
        }
        .ci-bar .range {
            position: absolute; height: 100%;
            background: linear-gradient(90deg, #3b82f6, #a78bfa, #ef4444);
            opacity: 0.6;
        }
        .ci-bar .point {
            position: absolute; height: 100%; width: 3px;
            background: #fff; top: 0;
        }
        .ci-bar .ticks {
            position: absolute; width: 100%; height: 100%;
            display: flex; justify-content: space-between;
            padding: 0 2px; font-size: 8px; color: #666;
            align-items: flex-end;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <h1>2026 Senate Forecast</h1>
            <p class="subtitle">Click states to select, double-click to lock outcomes</p>

            <div class="control-bar">
                <div class="control-stat dem">
                    <div class="label">D Control</div>
                    <div class="value" id="d-control">--</div>
                </div>
                <div class="control-stat">
                    <div class="label">Projected</div>
                    <div class="value" id="expected-seats">--</div>
                </div>
                <div class="control-stat rep">
                    <div class="label">R Control</div>
                    <div class="value" id="r-control">--</div>
                </div>
            </div>
            <div style="text-align: center; color: #666; font-size: 12px; margin-bottom: 15px;">
                <span title="Current Senate composition before 2026 elections">Pre-election: 53R-47D</span>
                <span style="margin: 0 10px;">•</span>
                <span title="Senators not up for re-election in 2026 (Class 1 & 3)">Not contested: 31R + 34D = 65 seats</span>
                <span style="margin: 0 10px;">•</span>
                <span title="Class 2 Senate seats being decided in 2026">35 races contested</span>
            </div>

            <div class="hex-map">
                <div class="hex-grid" id="hex-grid"></div>
            </div>

            <div class="snake-section">
                <h2>Races by Competitiveness (Tipping Point Analysis)</h2>
                <div class="snake-chart" id="snake-chart"></div>
            </div>

            <div class="histogram-section">
                <h2>Seat Count Distribution</h2>
                <div class="histogram-container">
                    <div class="histogram" id="histogram"></div>
                    <div class="histogram-labels">
                        <span>45D</span>
                        <span>50-50</span>
                        <span>55R</span>
                    </div>
                    <div class="histogram-legend">
                        <span><div class="legend-box dem"></div> D majority</span>
                        <span><div class="legend-box rep"></div> R majority</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <h2>Sample Statistics</h2>
            <div class="sample-stats" id="sample-stats">
                <div class="stat-row">
                    <span class="label">Total samples</span>
                    <span class="value" id="stat-total">--</span>
                </div>
                <div class="stat-row">
                    <span class="label">Filtered samples</span>
                    <span class="value" id="stat-filtered">--</span>
                </div>
                <div class="stat-row">
                    <span class="label" title="Accounts for correlation between samples. ESS = N / τ where τ is the integrated autocorrelation time." style="cursor: help;">Effective sample size</span>
                    <span class="value" id="stat-ess">--</span>
                </div>
                <div class="stat-row">
                    <span class="label" title="95% confidence interval width for D Control probability, using Wilson score interval." style="cursor: help;">Margin of error (95%)</span>
                    <span class="value" id="stat-moe">--</span>
                </div>
                <div class="stat-row">
                    <span class="label" title="Largest difference between model and market prices. Lower is better; >5% may indicate market inconsistency." style="cursor: help;">Max constraint error</span>
                    <span class="value" id="stat-max-error">--</span>
                </div>
                <div class="stat-row">
                    <span class="label" title="Root mean square of all constraint errors. Measures overall fit quality." style="cursor: help;">RMS error</span>
                    <span class="value" id="stat-rms-error">--</span>
                </div>
                <div class="stat-row">
                    <span class="label">Data fetched</span>
                    <span class="value" id="stat-timestamp" style="font-size: 10px;">--</span>
                </div>
                <div class="ci-display">
                    <div class="label">D Control probability (95% CI)</div>
                    <div class="ci-bar" id="ci-bar">
                        <div class="range" id="ci-range"></div>
                        <div class="point" id="ci-point"></div>
                        <div class="ticks"><span>0%</span><span>50%</span><span>100%</span></div>
                    </div>
                    <div style="text-align: center; font-size: 11px; margin-top: 5px; color: #888;" id="ci-text">--</div>
                </div>
            </div>

            <div id="top-maps-panel">
                <h2>Top Outcome Maps</h2>
                <div class="top-maps" id="top-maps">
                    <div style="color: #666; text-align: center;">Loading...</div>
                </div>
            </div>

            <details class="methodology">
                <summary>Methodology</summary>
                <p>This forecast uses Monte Carlo sampling to generate election scenarios consistent with all market constraints.</p>
                <dl>
                    <dt>Effective Sample Size (ESS)</dt>
                    <dd>Accounts for correlation between samples. Higher ESS means more reliable estimates. ESS = N / τ where τ is the integrated autocorrelation time.</dd>

                    <dt>Margin of Error (MoE)</dt>
                    <dd>95% confidence interval width for the D Control probability, computed using Wilson score interval based on ESS.</dd>

                    <dt>Max Constraint Error</dt>
                    <dd>Largest difference between model probabilities and market prices across all constraints. Lower is better; >5% suggests market prices may be internally inconsistent.</dd>

                    <dt>Correlated Races</dt>
                    <dd>Shows how probabilities shift if a race outcome is known. Example: "+8%" means that race's D probability increases 8 percentage points if the selected race goes D.</dd>
                </dl>
            </details>

            <div id="selected-panel">
                <h2>Selected Race</h2>
                <div class="selected-race" id="selected-race">
                    <div style="color: #666; text-align: center; padding: 20px;">
                        Click a state to see details
                    </div>
                </div>
            </div>

            <div id="locked-panel" style="display: none;">
                <h2>Locked Outcomes</h2>
                <div class="locked-summary" id="locked-summary"></div>
            </div>

            <div id="correlations-panel" style="display: none;">
                <h2>Correlated Races</h2>
                <div class="correlations" id="correlations">
                    <h3 title="Shows how each race's D probability changes if the selected race goes D. Example: +8% means that race is 8 percentage points more likely to go D when the selected race goes D.">If selected goes D, D prob shifts:</h3>
                    <div id="corr-list"></div>
                </div>
            </div>

            <div id="markets-panel">
                <h2>Related Markets</h2>
                <div class="markets-panel" id="markets-list"></div>
            </div>

            <button class="reset-all" id="reset-btn" style="display: none;">Reset All Locks</button>
            <div class="sample-count" id="sample-count"></div>
        </div>
    </div>

    <script>
    let samples = [];
    let races = [];
    let locks = {};
    let seatLock = null;  // Lock to specific R seat count (e.g., 51 = 51R/49D)
    let selected = null;
    let essEstimate = null;  // Cached ESS from full sample
    let markets = [];  // Market metadata
    let maxError = null;  // Max constraint error from sampler
    let rmsError = null;  // RMS constraint error
    let snapshotTimestamp = null;  // When data was fetched
    let topOutcomes = [];  // Top outcome maps from sampler
    let selectedMap = null;  // Currently selected outcome map (index)
    let marginals = {};  // Cached marginals for independent prob calculation

    // State abbreviation to full name
    const stateNames = {
        'AL': 'Alabama', 'AK': 'Alaska', 'AR': 'Arkansas', 'AZ': 'Arizona',
        'CA': 'California', 'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware',
        'FL': 'Florida', 'GA': 'Georgia', 'HI': 'Hawaii', 'ID': 'Idaho',
        'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa', 'KS': 'Kansas',
        'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
        'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi',
        'MO': 'Missouri', 'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada',
        'NH': 'New Hampshire', 'NJ': 'New Jersey', 'NM': 'New Mexico', 'NY': 'New York',
        'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio', 'OK': 'Oklahoma',
        'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
        'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah',
        'VT': 'Vermont', 'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia',
        'WI': 'Wisconsin', 'WY': 'Wyoming'
    };

    // Hex grid layout (approximate US shape)
    const hexLayout = [
        [null, null, null, null, null, null, null, null, null, null, 'ME', null],
        [null, null, null, null, null, null, 'WI', null, null, 'VT', 'NH', null],
        ['WA', 'MT', 'ND', 'MN', null, null, 'MI', null, 'NY', 'MA', null, null],
        ['OR', 'ID', 'SD', 'IA', 'IL', 'IN', 'OH', 'PA', 'NJ', 'CT', 'RI', null],
        ['NV', 'WY', 'NE', 'MO', 'KY', 'WV', 'VA', 'MD', 'DE', null, null, null],
        ['CA', 'UT', 'CO', 'KS', 'AR', 'TN', 'NC', 'SC', null, null, null, null],
        ['AZ', 'NM', 'OK', 'LA', 'MS', 'AL', 'GA', null, 'FL', null, null, null],
        [null, null, 'TX', null, null, null, null, null, null, null, 'AK', 'HI'],
    ];

    function getStateCode(race) {
        return race.replace('_Senate', '').replace('_Special', '');
    }

    function getStateName(race) {
        const code = getStateCode(race);
        const special = race.includes('Special') ? ' (Special)' : '';
        return (stateNames[code] || code) + special;
    }

    function getRaceForState(stateCode) {
        // Check for special first, then regular
        const special = races.find(r => r === stateCode + '_Senate_Special');
        if (special) return special;
        return races.find(r => r === stateCode + '_Senate');
    }

    function getColor(dProb, iProb = 0) {
        // If Independent is leading, use gold
        if (iProb > dProb && iProb > (1 - dProb - iProb)) {
            if (iProb > 0.7) return '#d97706';  // amber-600
            if (iProb > 0.5) return '#f59e0b';  // amber-500
            return '#fbbf24';  // amber-400
        }
        // Blue (D) to Red (R) gradient
        if (dProb > 0.9) return '#1d4ed8';
        if (dProb > 0.7) return '#3b82f6';
        if (dProb > 0.55) return '#60a5fa';
        if (dProb > 0.45) return '#a78bfa';
        if (dProb > 0.3) return '#f87171';
        if (dProb > 0.1) return '#ef4444';
        return '#b91c1c';
    }

    // Compute autocorrelation at lag k for a binary sequence
    function autocorrelation(values, lag) {
        const n = values.length;
        if (lag >= n) return 0;
        const mean = values.reduce((a, b) => a + b, 0) / n;
        const variance = values.reduce((a, b) => a + (b - mean) ** 2, 0) / n;
        if (variance === 0) return 0;

        let cov = 0;
        for (let i = 0; i < n - lag; i++) {
            cov += (values[i] - mean) * (values[i + lag] - mean);
        }
        return cov / ((n - lag) * variance);
    }

    // Estimate effective sample size from D Control indicator
    function estimateESS(samples) {
        // Compute D control indicator (binary)
        const dControlIndicator = samples.map(s => {
            const rWins = races.filter(r => s[r] === 'R').length;
            return (35 - rWins >= 17) ? 1 : 0;
        });

        // Estimate integrated autocorrelation time using initial sequence estimator
        // τ = 1 + 2 * sum(ρ(k)) for k where ρ(k) > 0
        let tau = 1;
        const maxLag = Math.min(100, Math.floor(samples.length / 4));
        for (let k = 1; k < maxLag; k++) {
            const rho = autocorrelation(dControlIndicator, k);
            if (rho < 0.05) break;  // Truncate when autocorrelation is negligible
            tau += 2 * rho;
        }

        return {
            n: samples.length,
            tau: tau,
            ess: Math.round(samples.length / tau)
        };
    }

    // Compute confidence interval for a proportion
    function binomialCI(p, n, z = 1.96) {
        // Wilson score interval (better for edge cases)
        const denominator = 1 + z * z / n;
        const center = (p + z * z / (2 * n)) / denominator;
        const halfWidth = z * Math.sqrt((p * (1 - p) + z * z / (4 * n)) / n) / denominator;
        return {
            low: Math.max(0, center - halfWidth),
            high: Math.min(1, center + halfWidth),
            moe: halfWidth
        };
    }

    async function loadData() {
        // Load samples
        const cacheBust = '?v=' + Date.now();
        const samplesResp = await fetch('data/samples.json' + cacheBust);
        const samplesData = await samplesResp.json();
        samples = samplesData.samples;
        races = samplesData.races;

        // Load summary (includes markets metadata and max error)
        const summaryResp = await fetch('data/summary.json' + cacheBust);
        const summaryData = await summaryResp.json();
        markets = summaryData.markets || [];
        maxError = summaryData.metadata?.max_error || null;
        rmsError = summaryData.metadata?.rms_error || null;
        snapshotTimestamp = summaryData.metadata?.snapshot_timestamp || null;
        topOutcomes = summaryData.top_outcomes || [];
        marginals = summaryData.marginals || {};
        console.log('Top outcomes loaded:', topOutcomes.length);

        // Estimate ESS from full sample (cache it)
        essEstimate = estimateESS(samples);
        console.log('ESS estimate:', essEstimate);
        console.log('Markets loaded:', markets.length, markets.map(m => m.name));
        console.log('Max error:', maxError);
        console.log('Snapshot timestamp:', snapshotTimestamp);

        document.getElementById('sample-count').textContent =
            `Source: ${samples.length.toLocaleString()} samples, ESS ≈ ${essEstimate.ess.toLocaleString()}`;
        render();
    }

    function getFilteredSamples() {
        return samples.filter(s => {
            // Filter by race locks
            for (const [race, outcome] of Object.entries(locks)) {
                if (s[race] !== outcome) return false;
            }
            // Filter by seat count lock
            if (seatLock !== null) {
                const rWins = races.filter(r => s[r] === 'R').length;
                const totalR = 31 + rWins;
                if (totalR !== seatLock) return false;
            }
            return true;
        });
    }

    function computeStats(filteredSamples) {
        if (filteredSamples.length === 0) {
            return { marginals: {}, dControl: 0, rControl: 0, expectedR: 0 };
        }

        const marginals = {};
        for (const race of races) {
            // Count all outcomes for this race
            const outcomes = {};
            for (const s of filteredSamples) {
                const outcome = s[race];
                outcomes[outcome] = (outcomes[outcome] || 0) + 1;
            }
            // Normalize to probabilities
            marginals[race] = {};
            for (const [outcome, count] of Object.entries(outcomes)) {
                marginals[race][outcome] = count / filteredSamples.length;
            }
            // Ensure D and R exist (for binary races)
            if (!marginals[race].D) marginals[race].D = 0;
            if (!marginals[race].R) marginals[race].R = 0;
        }

        let dControlCount = 0;
        let totalRWins = 0;
        for (const s of filteredSamples) {
            const rWins = races.filter(r => s[r] === 'R').length;
            totalRWins += rWins;
            // D control requires D + I (caucusing) >= 51 total
            // With baseline 34D + 31R, D needs 17 wins from 35 races (34 + 17 = 51)
            // Note: Independent who doesn't caucus with D counts against D control
            // For now, treat I outcomes as NOT contributing to either D or R control
            const dWins = races.filter(r => s[r] === 'D').length;
            // D needs 51 total. Has 34 baseline. Needs 17 D wins.
            // But if NE goes Independent, it's neither D nor R win
            // Current simplification: D control = D baseline + D wins >= 51
            if (34 + dWins >= 51) dControlCount++;
        }

        return {
            marginals,
            dControl: dControlCount / filteredSamples.length,
            rControl: 1 - dControlCount / filteredSamples.length,
            expectedR: totalRWins / filteredSamples.length
        };
    }

    function computeCorrelations(race, marginals, filteredSamples) {
        if (!race || filteredSamples.length < 100) return [];

        const baseProb = marginals[race]?.D || 0.5;
        const correlations = [];

        for (const other of races) {
            if (other === race) continue;

            // P(other=D | race=D)
            const bothD = filteredSamples.filter(s => s[race] === 'D' && s[other] === 'D').length;
            const raceD = filteredSamples.filter(s => s[race] === 'D').length;
            const conditionalProb = raceD > 0 ? bothD / raceD : 0;
            const baseOtherProb = marginals[other]?.D || 0.5;
            const lift = conditionalProb - baseOtherProb;

            correlations.push({ race: other, lift, conditionalProb });
        }

        correlations.sort((a, b) => Math.abs(b.lift) - Math.abs(a.lift));
        return correlations.slice(0, 5);
    }

    // Compute independent probability for a specific outcome map
    // Returns P(map) = ∏ P(state=outcome) assuming independence
    function computeIndependentProb(outcomeMap) {
        if (!marginals || Object.keys(marginals).length === 0) return null;

        let logProb = 0;
        for (const [race, outcome] of Object.entries(outcomeMap)) {
            const raceProbs = marginals[race];
            if (!raceProbs) continue;
            const p = raceProbs[outcome] || 0.001;  // Small floor to avoid log(0)
            logProb += Math.log(p);
        }
        return Math.exp(logProb);
    }

    function selectMap(index) {
        selectedMap = (selectedMap === index) ? null : index;
        render();
    }

    function renderTopMaps() {
        const container = document.getElementById('top-maps');

        if (topOutcomes.length === 0) {
            container.innerHTML = '<div style="color: #666; text-align: center;">No outcome data</div>';
            return;
        }

        // Find max probability for bar scaling
        const maxProb = Math.max(...topOutcomes.slice(0, 15).map(o => o.model_prob));

        let html = '';
        const displayCount = Math.min(15, topOutcomes.length);

        for (let i = 0; i < displayCount; i++) {
            const outcome = topOutcomes[i];
            const barWidth = (outcome.model_prob / maxProb) * 100;
            const isSelected = selectedMap === i;
            const controlClass = outcome.control === 'R' ? 'r-control' : 'd-control';

            html += `
                <div class="map-item ${isSelected ? 'selected' : ''}" onclick="selectMap(${i})">
                    <span class="rank">#${outcome.rank}</span>
                    <div class="bar-container">
                        <div class="bar ${controlClass}" style="width: ${barWidth}%">
                            ${outcome.model_prob.toFixed(1)}%
                        </div>
                    </div>
                    <span class="seats">${outcome.r_seats}R-${outcome.d_seats}D</span>
                </div>
            `;
        }

        // Detail panel for selected map
        if (selectedMap !== null && topOutcomes[selectedMap]) {
            const outcome = topOutcomes[selectedMap];

            // Compute independent probability directly from marginals
            const indepProb = outcome.outcomes ? computeIndependentProb(outcome.outcomes) : null;
            const indepPct = indepProb ? (indepProb * 100) : outcome.indep_prob;
            const ratio = indepPct > 0 ? (outcome.model_prob / indepPct) : 0;

            html += `
                <div class="map-detail">
                    <div class="stat-row">
                        <span class="label">Model probability</span>
                        <span class="value">${outcome.model_prob.toFixed(2)}%</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Independent probability</span>
                        <span class="value">${indepPct.toFixed(2)}%</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Correlation boost</span>
                        <span class="value" style="color: ${ratio > 1.5 ? '#22c55e' : ratio < 0.7 ? '#ef4444' : '#888'}">
                            ${ratio.toFixed(2)}×
                        </span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Control</span>
                        <span class="value" style="color: ${outcome.control === 'R' ? '#ef4444' : '#3b82f6'}">
                            ${outcome.control === 'R' ? 'Republican' : 'Democrat'}
                        </span>
                    </div>
                    ${outcome.upsets && outcome.upsets.length > 0 ? `
                        <div class="upsets">
                            <span class="label">Upsets vs baseline:</span>
                            <div style="margin-top: 4px;">
                                ${outcome.upsets.map(u => `<span class="upset-tag">${u}</span>`).join('')}
                            </div>
                        </div>
                    ` : `
                        <div class="upsets">
                            <span class="label" style="color: #22c55e;">No upsets (baseline scenario)</span>
                        </div>
                    `}
                </div>
                <button class="clear-map-btn" onclick="selectMap(null)">Clear selection</button>
            `;
        }

        container.innerHTML = html;
    }

    function render() {
        const filtered = getFilteredSamples();
        const stats = computeStats(filtered);

        // Update control bar
        document.getElementById('d-control').textContent =
            filtered.length > 0 ? (stats.dControl * 100).toFixed(0) + '%' : '--';
        document.getElementById('r-control').textContent =
            filtered.length > 0 ? (stats.rControl * 100).toFixed(0) + '%' : '--';
        const projectedR = filtered.length > 0 ? Math.round(31 + stats.expectedR) : null;
        document.getElementById('expected-seats').textContent =
            projectedR !== null ? `${projectedR}R-${100-projectedR}D` : '--';

        // Update sample statistics
        const nLocks = Object.keys(locks).length;
        // When filtering, ESS scales proportionally to sample fraction
        const effectiveFiltered = nLocks > 0 ? filtered.length : samples.length;
        const essFraction = effectiveFiltered / samples.length;
        const currentESS = Math.round((essEstimate?.ess || filtered.length) * essFraction);

        document.getElementById('stat-total').textContent = samples.length.toLocaleString();
        const filteredEl = document.getElementById('stat-filtered');
        filteredEl.textContent = filtered.length.toLocaleString();
        filteredEl.className = 'value' + (filtered.length < 100 ? ' error' : filtered.length < 500 ? ' warning' : '');

        document.getElementById('stat-ess').textContent = currentESS.toLocaleString();

        // Display max constraint error
        const maxErrEl = document.getElementById('stat-max-error');
        if (maxError !== null) {
            maxErrEl.textContent = (maxError * 100).toFixed(1) + '%';
            maxErrEl.className = 'value' + (maxError > 0.1 ? ' error' : maxError > 0.05 ? ' warning' : '');
        } else {
            maxErrEl.textContent = '--';
        }

        // Display RMS constraint error
        const rmsErrEl = document.getElementById('stat-rms-error');
        if (rmsError !== null) {
            rmsErrEl.textContent = (rmsError * 100).toFixed(1) + '%';
            rmsErrEl.className = 'value' + (rmsError > 0.05 ? ' error' : rmsError > 0.025 ? ' warning' : '');
        } else {
            rmsErrEl.textContent = '--';
        }

        // Display snapshot timestamp
        const tsEl = document.getElementById('stat-timestamp');
        if (snapshotTimestamp) {
            const ts = new Date(snapshotTimestamp);
            tsEl.textContent = ts.toLocaleDateString() + ' ' + ts.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        } else {
            tsEl.textContent = '--';
        }

        // Compute confidence interval for D control
        if (filtered.length > 0) {
            const ci = binomialCI(stats.dControl, currentESS);
            const moeEl = document.getElementById('stat-moe');
            moeEl.textContent = '±' + (ci.moe * 100).toFixed(1) + '%';
            moeEl.className = 'value' + (ci.moe > 0.1 ? ' warning' : '');

            // Update CI bar
            document.getElementById('ci-range').style.left = (ci.low * 100) + '%';
            document.getElementById('ci-range').style.width = ((ci.high - ci.low) * 100) + '%';
            document.getElementById('ci-point').style.left = (stats.dControl * 100) + '%';
            document.getElementById('ci-text').textContent =
                `${(ci.low * 100).toFixed(1)}% – ${(stats.dControl * 100).toFixed(1)}% – ${(ci.high * 100).toFixed(1)}%`;
        } else {
            document.getElementById('stat-moe').textContent = '--';
            document.getElementById('ci-text').textContent = '--';
        }

        // Render hex map
        const hexGrid = document.getElementById('hex-grid');
        hexGrid.innerHTML = '';

        // Get selected outcome map if any
        const selectedOutcome = (selectedMap !== null && topOutcomes[selectedMap])
            ? topOutcomes[selectedMap].outcomes
            : null;

        for (const row of hexLayout) {
            for (const stateCode of row) {
                const cell = document.createElement('div');
                cell.className = 'hex-cell';

                if (!stateCode) {
                    cell.classList.add('empty');
                } else {
                    const race = getRaceForState(stateCode);
                    if (race) {
                        // If showing a specific outcome map, use solid colors
                        if (selectedOutcome && selectedOutcome[race]) {
                            const outcome = selectedOutcome[race];
                            if (outcome === 'D') {
                                cell.style.background = '#3b82f6';
                                cell.innerHTML = `${stateCode}<span class="prob">D</span>`;
                            } else if (outcome === 'R') {
                                cell.style.background = '#ef4444';
                                cell.innerHTML = `${stateCode}<span class="prob">R</span>`;
                            } else {
                                cell.style.background = '#fbbf24';
                                cell.innerHTML = `${stateCode}<span class="prob">I</span>`;
                            }
                            cell.title = `${getStateName(race)}: ${outcome}`;
                        } else {
                            // Show marginal probabilities
                            const m = stats.marginals[race] || { D: 0.5, R: 0.5 };
                            const iProb = (m.I_Osborn || 0) + (m.I_Other || 0);
                            const dPct = (m.D * 100).toFixed(0);
                            cell.style.background = getColor(m.D, iProb);
                            // Show leading outcome's probability
                            const leadingPct = iProb > m.D && iProb > m.R ?
                                (iProb * 100).toFixed(0) + 'I' :
                                m.D > m.R ? dPct + 'D' : ((m.R * 100).toFixed(0) + 'R');
                            cell.innerHTML = `${stateCode}<span class="prob">${leadingPct.slice(0,-1)}</span>`;
                            cell.title = getStateName(race);
                        }

                        if (locks[race]) cell.classList.add('locked');
                        if (selected === race) cell.classList.add('selected');

                        cell.addEventListener('click', () => selectRace(race));
                        cell.addEventListener('dblclick', () => toggleLock(race));
                    } else {
                        cell.style.background = '#333';
                        cell.textContent = stateCode;
                        cell.style.opacity = 0.3;
                    }
                }
                hexGrid.appendChild(cell);
            }
        }

        // Render snake chart
        // Sort by P(R): lowest P(R) on left (D-leaning), highest P(R) on right (R-leaning)
        // This handles multi-outcome races correctly (NE with I counts as "not R")
        const sortedRaces = [...races].sort((a, b) => {
            // Locked races: D-locked → 0% R (far left), R-locked → 100% R (far right)
            // I-locked → same as marginal P(R) since I isn't R
            const aR = locks[a] === 'D' ? 0.0 : locks[a] === 'R' ? 1.0 :
                       locks[a]?.startsWith('I_') ? (stats.marginals[a]?.R || 0) : (stats.marginals[a]?.R || 0.5);
            const bR = locks[b] === 'D' ? 0.0 : locks[b] === 'R' ? 1.0 :
                       locks[b]?.startsWith('I_') ? (stats.marginals[b]?.R || 0) : (stats.marginals[b]?.R || 0.5);
            return aR - bR;  // Lower P(R) first (leftmost), higher P(R) last (rightmost)
        });

        const snakeChart = document.getElementById('snake-chart');
        snakeChart.innerHTML = '';

        for (const race of sortedRaces) {
            const m = stats.marginals[race] || { D: 0.5, R: 0.5 };
            const iProb = (m.I_Osborn || 0) + (m.I_Other || 0);
            const item = document.createElement('div');
            item.className = 'snake-item';
            if (locks[race]) item.classList.add('locked');
            if (selected === race) item.classList.add('selected');

            // If showing a specific outcome map, use solid colors
            if (selectedOutcome && selectedOutcome[race]) {
                const outcome = selectedOutcome[race];
                if (outcome === 'D') {
                    item.style.background = '#3b82f6';
                    item.innerHTML = `<span class="state">${getStateCode(race)}</span><span class="pct">D</span>`;
                } else if (outcome === 'R') {
                    item.style.background = '#ef4444';
                    item.innerHTML = `<span class="state">${getStateCode(race)}</span><span class="pct">R</span>`;
                } else {
                    item.style.background = '#fbbf24';
                    item.innerHTML = `<span class="state">${getStateCode(race)}</span><span class="pct">I</span>`;
                }
                item.title = `${getStateName(race)}: ${outcome}`;
            } else {
                item.style.background = getColor(m.D, iProb);
                // Show leading probability
                const leadPct = iProb > m.D && iProb > m.R ?
                    (iProb * 100).toFixed(0) + '% I' :
                    m.D > m.R ? (m.D * 100).toFixed(0) + '% D' : (m.R * 100).toFixed(0) + '% R';
                item.innerHTML = `
                    <span class="state">${getStateCode(race)}</span>
                    <span class="pct">${leadPct}</span>
                `;
                item.title = getStateName(race);
            }
            item.addEventListener('click', () => selectRace(race));
            item.addEventListener('dblclick', () => toggleLock(race));
            snakeChart.appendChild(item);
        }

        // Render histogram
        renderHistogram(filtered);

        // Render top outcome maps
        renderTopMaps();

        // Update sidebar
        updateSidebar(stats, filtered);
    }

    function renderHistogram(filteredSamples) {
        const histogram = document.getElementById('histogram');

        if (filteredSamples.length === 0) {
            histogram.innerHTML = '<div style="color: #666; text-align: center; width: 100%;">No matching samples</div>';
            return;
        }

        // Count total seats per sample (R seats from 35 races + 31 baseline R = 66 - D seats)
        // We have 35 races up for election. Current split before election: 34D, 31R = 65
        // After election: (34 - D_losses + D_wins) D seats
        // Total Senate = 100, so R = 100 - D
        // The races array has 35 races. Base is 65 senators not up (computed from 34D + 31R)
        // Actually, looking at the data: baseline D=34, R=31, 35 races
        // For each sample, we count R wins in the 35 races, add to baseline 31

        const seatCounts = {};
        for (const s of filteredSamples) {
            const rWins = races.filter(r => s[r] === 'R').length;
            const totalR = 31 + rWins;  // 31 baseline R + R wins from 35 races
            seatCounts[totalR] = (seatCounts[totalR] || 0) + 1;
        }

        // Find range and max
        const seats = Object.keys(seatCounts).map(Number);
        const minSeat = Math.min(...seats, 45);  // At least show 45-55 range
        const maxSeat = Math.max(...seats, 55);
        const maxCount = Math.max(...Object.values(seatCounts));

        // Build bars
        histogram.innerHTML = '';
        for (let seat = minSeat; seat <= maxSeat; seat++) {
            const count = seatCounts[seat] || 0;
            const pct = count / filteredSamples.length;
            const height = maxCount > 0 ? (count / maxCount) * 100 : 0;

            const bar = document.createElement('div');
            bar.className = 'hist-bar ' + (seat < 50 ? 'dem' : 'rep');
            if (seatLock === seat) bar.classList.add('locked');
            bar.style.height = height + '%';
            bar.title = `${seat}R / ${100-seat}D: ${(pct * 100).toFixed(1)}% (${count.toLocaleString()} samples)\nClick to lock, click again to unlock`;
            bar.addEventListener('click', () => toggleSeatLock(seat));
            histogram.appendChild(bar);
        }

        // Update labels to match actual range
        const labels = document.querySelector('.histogram-labels');
        labels.innerHTML = `
            <span>${100 - minSeat}D</span>
            <span>50-50</span>
            <span>${maxSeat}R</span>
        `;
    }

    function selectRace(race) {
        selected = (selected === race) ? null : race;
        render();
    }

    function toggleSeatLock(seats) {
        seatLock = (seatLock === seats) ? null : seats;
        render();
    }

    function toggleLock(race) {
        const filtered = getFilteredSamples();
        const stats = computeStats(filtered);
        const m = stats.marginals[race] || { D: 0.5 };
        const hasIndependent = m.I_Osborn !== undefined;

        if (locks[race]) {
            // Cycle through outcomes
            if (hasIndependent) {
                // D → R → I_Osborn → unlock
                if (locks[race] === 'D') locks[race] = 'R';
                else if (locks[race] === 'R') locks[race] = 'I_Osborn';
                else delete locks[race];
            } else {
                // D → R → unlock
                if (locks[race] === 'D') locks[race] = 'R';
                else delete locks[race];
            }
        } else {
            // Lock to leading outcome
            const iProb = (m.I_Osborn || 0) + (m.I_Other || 0);
            if (iProb > m.D && iProb > m.R) {
                locks[race] = 'I_Osborn';
            } else {
                locks[race] = m.D > m.R ? 'D' : 'R';
            }
        }
        render();
    }

    function updateSidebar(stats, filtered) {
        // Selected race panel
        const selectedRace = document.getElementById('selected-race');
        if (selected) {
            const m = stats.marginals[selected] || { D: 0.5, R: 0.5 };
            const isLocked = locks[selected];
            const hasIndependent = m.I_Osborn !== undefined || m.I_Other !== undefined;
            const iOsborn = m.I_Osborn || 0;
            const iOther = m.I_Other || 0;

            let probDisplay = `
                <div class="prob-item dem">
                    <div class="party">Democrat</div>
                    <div class="pct">${(m.D * 100).toFixed(1)}%</div>
                </div>
                <div class="prob-item rep">
                    <div class="party">Republican</div>
                    <div class="pct">${(m.R * 100).toFixed(1)}%</div>
                </div>`;

            if (hasIndependent) {
                probDisplay += `
                <div class="prob-item" style="color: #fbbf24;">
                    <div class="party">Osborn (I)</div>
                    <div class="pct">${(iOsborn * 100).toFixed(1)}%</div>
                </div>`;
                if (iOther > 0.001) {
                    probDisplay += `
                <div class="prob-item" style="color: #d97706;">
                    <div class="party">Other (I)</div>
                    <div class="pct">${(iOther * 100).toFixed(1)}%</div>
                </div>`;
                }
            }

            let lockButtons = `
                <button class="lock-d" onclick="lockRace('${selected}', 'D')">Lock D</button>
                <button class="lock-r" onclick="lockRace('${selected}', 'R')">Lock R</button>`;
            if (hasIndependent) {
                lockButtons += `
                <button style="background: #f59e0b; color: #000;" onclick="lockRace('${selected}', 'I_Osborn')">Lock Osborn</button>`;
            }
            if (isLocked) {
                lockButtons += `<button class="unlock" onclick="unlockRace('${selected}')">Unlock</button>`;
            }

            selectedRace.innerHTML = `
                <div class="state-name">${getStateName(selected)}</div>
                <div class="race-type">${selected.includes('Special') ? 'Special Election' : 'Class 2 Senate Race'}</div>
                <div class="prob-display" style="flex-wrap: wrap;">
                    ${probDisplay}
                </div>
                <div class="actions">
                    ${lockButtons}
                </div>
            `;

            // Show correlations
            const correlations = computeCorrelations(selected, stats.marginals, filtered);
            const corrPanel = document.getElementById('correlations-panel');
            const corrList = document.getElementById('corr-list');
            if (correlations.length > 0) {
                corrPanel.style.display = 'block';
                corrList.innerHTML = correlations.map(c => `
                    <div class="corr-item">
                        <span>${getStateCode(c.race)}</span>
                        <span class="val ${c.lift > 0 ? 'pos' : 'neg'}">${c.lift > 0 ? '+' : ''}${(c.lift * 100).toFixed(1)}%</span>
                    </div>
                `).join('');
            } else {
                corrPanel.style.display = 'none';
            }
        } else {
            selectedRace.innerHTML = `<div style="color: #666; text-align: center; padding: 20px;">Click a state to see details</div>`;
            document.getElementById('correlations-panel').style.display = 'none';
        }

        // Locked panel
        const lockedPanel = document.getElementById('locked-panel');
        const lockedSummary = document.getElementById('locked-summary');
        const lockedRaces = Object.entries(locks);

        const hasLocks = lockedRaces.length > 0 || seatLock !== null;
        if (hasLocks) {
            lockedPanel.style.display = 'block';
            document.getElementById('reset-btn').style.display = 'block';
            let html = '';
            if (seatLock !== null) {
                html += `<div class="locked-item">
                    <span>Seat count</span>
                    <span class="outcome" style="color: #fbbf24;">${seatLock}R / ${100-seatLock}D</span>
                </div>`;
            }
            html += lockedRaces.map(([race, outcome]) => {
                const displayOutcome = outcome === 'I_Osborn' ? 'Osborn (I)' :
                                       outcome === 'I_Other' ? 'Other (I)' : outcome;
                return `
                <div class="locked-item">
                    <span>${getStateCode(race)}</span>
                    <span class="outcome ${outcome}">${displayOutcome}</span>
                </div>`;
            }).join('');
            html += `<div style="color: #666; font-size: 11px; margin-top: 8px;">${filtered.length} matching samples</div>`;
            lockedSummary.innerHTML = html;
        } else {
            lockedPanel.style.display = 'none';
            document.getElementById('reset-btn').style.display = 'none';
        }

        // Markets panel
        const marketsList = document.getElementById('markets-list');
        const marketsHeader = document.querySelector('#markets-panel h2');
        console.log('Rendering markets panel, selected:', selected, 'markets:', markets.length);

        if (markets.length > 0) {
            // Sort markets: relevant to selected state first, then by volume
            let sortedMarkets = [...markets];
            if (selected) {
                sortedMarkets.sort((a, b) => {
                    const aRelevant = a.related_races.includes(selected);
                    const bRelevant = b.related_races.includes(selected);
                    if (aRelevant && !bRelevant) return -1;
                    if (!aRelevant && bRelevant) return 1;
                    return (b.volume || 0) - (a.volume || 0);
                });
                marketsHeader.textContent = `Markets (${getStateCode(selected)})`;
            } else {
                sortedMarkets.sort((a, b) => (b.volume || 0) - (a.volume || 0));
                marketsHeader.textContent = 'All Markets';
            }

            marketsList.innerHTML = sortedMarkets.map(m => {
                const isRelevant = selected && m.related_races.includes(selected);
                const volStr = m.volume >= 1000 ? `${(m.volume/1000).toFixed(1)}k` : Math.round(m.volume);

                // Get price comparison for this market
                let priceCompare = '';
                if (m.prices && Object.keys(m.prices).length > 0) {
                    if (m.type === 'multi_race' && selected) {
                        // For omnibus, show selected state's price vs model
                        // Use exact full-name matching (substring matching fails: "ME" matches "New Mexico")
                        const stateCode = getStateCode(selected);
                        const fullName = stateNames[stateCode];
                        const isSpecial = selected.includes('Special');
                        const stateName = Object.keys(m.prices).find(k => {
                            if (k === fullName) return true;
                            // Handle special elections: "Ohio (Special)" or "Florida (Special)"
                            if (isSpecial && k === fullName + ' (Special)') return true;
                            return false;
                        });
                        if (stateName && m.prices[stateName] !== undefined) {
                            const mktPrice = m.prices[stateName];
                            const modelProb = stats.marginals[selected]?.R || 0;
                            const diff = modelProb - mktPrice;
                            const diffClass = Math.abs(diff) > 0.05 ? 'warning' : '';
                            priceCompare = `<div class="price-compare ${diffClass}">
                                ${stateName}: Mkt ${(mktPrice*100).toFixed(0)}% vs Model ${(modelProb*100).toFixed(0)}%
                                <span class="diff">(${diff > 0 ? '+' : ''}${(diff*100).toFixed(1)}%)</span>
                            </div>`;
                        }
                    } else if (m.type === 'control') {
                        // R Senate Control market
                        const mktPrice = m.prices['YES'] || 0;
                        const modelProb = 1 - (stats.dControl || 0);
                        const diff = modelProb - mktPrice;
                        const diffClass = Math.abs(diff) > 0.05 ? 'warning' : '';
                        priceCompare = `<div class="price-compare ${diffClass}">
                            R Control: Mkt ${(mktPrice*100).toFixed(0)}% vs Model ${(modelProb*100).toFixed(0)}%
                            <span class="diff">(${diff > 0 ? '+' : ''}${(diff*100).toFixed(1)}%)</span>
                        </div>`;
                    } else if (m.type === 'joint_control') {
                        // Balance of Power - show D Senate probability
                        const dSenate = (m.prices['Democratic House and Senate'] || 0) +
                                       (m.prices['Republican House, Democratic Senate'] || 0);
                        const modelDControl = stats.dControl || 0;
                        const diff = modelDControl - dSenate;
                        const diffClass = Math.abs(diff) > 0.05 ? 'warning' : '';
                        priceCompare = `<div class="price-compare ${diffClass}">
                            D Senate: Mkt ${(dSenate*100).toFixed(0)}% vs Model ${(modelDControl*100).toFixed(0)}%
                            <span class="diff">(${diff > 0 ? '+' : ''}${(diff*100).toFixed(1)}%)</span>
                        </div>`;
                    }
                }

                return `
                    <div class="market-item ${isRelevant ? 'relevant' : ''}">
                        <a href="${m.url}" target="_blank">${m.name}</a>
                        ${priceCompare}
                        <div class="market-meta">
                            <span class="vol">M$${volStr} vol</span> ·
                            <span class="bettors">${m.uniqueBettorCount} traders</span>
                            ${m.related_races.length > 0 && m.related_races.length < 10 ? ` · ${m.related_races.length} races` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        } else {
            marketsList.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">No markets loaded</div>';
        }
    }

    function lockRace(race, outcome) {
        locks[race] = outcome;
        render();
    }

    function unlockRace(race) {
        delete locks[race];
        render();
    }

    document.getElementById('reset-btn').addEventListener('click', () => {
        locks = {};
        seatLock = null;
        render();
    });

    loadData();
    </script>
</body>
</html>
